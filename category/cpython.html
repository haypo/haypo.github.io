<!DOCTYPE html>
<html lang="en">
<head>
        <meta charset="utf-8" />
        <title>Victor Stinner blog 3 - cpython</title>
        <link rel="stylesheet" href="https://vstinner.github.io/theme/css/main.css" />
        <link href="https://vstinner.github.io/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="Victor Stinner blog 3 Atom Feed" />
</head>

<body id="index" class="home">
        <header id="banner" class="body">
                <h1><a href="https://vstinner.github.io/">Victor Stinner blog 3 </a></h1>
                <nav><ul>
                    <li><a href="https://vstinner.github.io/category/benchmark.html">benchmark</a></li>
                    <li class="active"><a href="https://vstinner.github.io/category/cpython.html">cpython</a></li>
                    <li><a href="https://vstinner.github.io/category/linux.html">linux</a></li>
                    <li><a href="https://vstinner.github.io/category/python.html">python</a></li>
                </ul></nav>
        </header><!-- /#banner -->

            <aside id="featured" class="body">
                <article>
                    <h1 class="entry-title"><a href="https://vstinner.github.io/gil-bugfixes-daemon-threads-python39.html">GIL bugfixes for daemon threads in Python 3.9</a></h1>
<footer class="post-info">
        <abbr class="published" title="2020-04-04T22:00:00+02:00">
                Published: sam. 04 avril 2020
        </abbr>

        <address class="vcard author">
                By                         <a class="url fn" href="https://vstinner.github.io/author/victor-stinner.html">Victor Stinner</a>
        </address>
<p>In <a href="https://vstinner.github.io/category/cpython.html">cpython</a>.</p>
<p>tags: <a href="https://vstinner.github.io/tag/cpython.html">cpython</a> </p>
</footer><!-- /.post-info --><p>My previous article <a class="reference external" href="https://vstinner.github.io/daemon-threads-python-finalization-python32.html">Daemon threads and the Python finalization in Python 3.2 and 3.3</a> introduces
issues caused by daemon threads in the Python finalization and past changes to
make them work.</p>
<p>This article is about bugfixes of the infamous GIL (Global Interpreter Lock) in
Python 3.9, between March 2019 and March 2020, for daemon threads during Python
finalization. Some bugs were old: up to 6 years old. Some bugs were triggered
by the on-going work on isolating subinterpreters in Python 3.9.</p>
<a class="reference external image-reference" href="https://twitter.com/Bouletcorp/status/1241018332112998401"><img alt="`#CoronaMaison by Boulet" src="https://vstinner.github.io/images/coronamaison_boulet.jpg" /></a>
<p>Drawing: <a class="reference external" href="https://twitter.com/Bouletcorp/status/1241018332112998401">#CoronaMaison by Boulet</a>.</p>
<div class="section" id="fix-1-exit-pyeval-acquirethread-if-finalizing">
<h2>Fix 1: Exit PyEval_AcquireThread() if finalizing</h2>
<p>In March 2019, <strong>Remy Noel</strong> created <a class="reference external" href="https://bugs.python.org/issue36469">bpo-36469</a>: a multithreaded Python application
using 20 daemon threads hangs randomly at exit on Python 3.5:</p>
<blockquote>
The bug happens about once every two weeks on a script that is fired more
than 10K times a day.</blockquote>
<p><strong>Eric Snow</strong> analyzed the bug and understood that it is related to daemon
threads and Python finalization. He identified that <tt class="docutils literal">PyEval_AcquireLock()</tt>
and <tt class="docutils literal">PyEval_AcquireThread()</tt> function take the GIL but don't exit the thread
if Python is finalizing.</p>
<p>When Python is finalizing and a daemon thread takes the GIL, Python can hang
randomly.</p>
<p>Eric created <a class="reference external" href="https://bugs.python.org/issue36475">bpo-36475</a> to propose to
modify <tt class="docutils literal">PyEval_AcquireLock()</tt> and <tt class="docutils literal">PyEval_AcquireThread()</tt> to also exit
the thread in this case. In April 2019, <strong>Joannah Nanjekye</strong> fixed the issue
with <a class="reference external" href="https://github.com/python/cpython/commit/f781d202a2382731b43bade845a58d28a02e9ea1">commit f781d202</a>:</p>
<pre class="literal-block">
bpo-36475: Finalize PyEval_AcquireLock() and PyEval_AcquireThread() properly (GH-12667)

PyEval_AcquireLock() and PyEval_AcquireThread() now
terminate the current thread if called while the interpreter is
finalizing, making them consistent with PyEval_RestoreThread(),
Py_END_ALLOW_THREADS, and PyGILState_Ensure().
</pre>
<p>The fix adds <tt class="docutils literal">exit_thread_if_finalizing()</tt> function which exit the thread if
Python is finalizing. This function is called after each <tt class="docutils literal">take_gil()</tt> call.</p>
<p>The fix is very similar to <tt class="docutils literal">PyEval_RestoreThread()</tt> fix made in 2013 (<a class="reference external" href="https://github.com/python/cpython/commit/0d5e52d3469a310001afe50689f77ddba6d554d1">commit
0d5e52d3</a>)
to fix <a class="reference external" href="https://bugs.python.org/issue1856#msg60014">bpo-1856</a> (Python crash
involving daemon threads during Python exit).</p>
</div>
<div class="section" id="fix-2-pyeval-restorethread-on-freed-tstate">
<h2>Fix 2: PyEval_RestoreThread() on freed tstate</h2>
<div class="section" id="concurrent-futures-crash-on-freebsd">
<h3>concurrent.futures crash on FreeBSD</h3>
<p>In December 2019, I reported <a class="reference external" href="https://bugs.python.org/issue39088">bpo-39088</a>:
test_concurrent_futures <strong>crashed randomly</strong> with a coredump on AMD64 FreeBSD
Shared 3.x buildbot. In March 2020, I succeeded to reproduce the bug on FreeBSD
and I was able to debug the coredump in gdb:</p>
<pre class="literal-block">
(gdb) frame
#0  0x00000000003b518c in PyEval_RestoreThread (tstate=0x801f23790) at Python/ceval.c:387
387         _PyRuntimeState *runtime = tstate-&gt;interp-&gt;runtime;

(gdb) p tstate-&gt;interp
$3 = (PyInterpreterState *) 0xdddddddddddddddd
</pre>
<p>The Python thread state (<tt class="docutils literal">tstate</tt>) was freed. In debug mode, the &quot;free()&quot;
function of the Python memory allocator fills the freed memory block with
<tt class="docutils literal">0xDD</tt> byte pattern (<tt class="docutils literal">D</tt> stands for dead byte) to detect usage of freed
memory.</p>
<p>The problem is that Python finalization already freed the memory of all
PyThreadState structures, when <tt class="docutils literal">PyEval_RestoreThread(tstate)</tt> is called by a
daemon thread. <tt class="docutils literal">PyEval_RestoreThread()</tt> dereferences <tt class="docutils literal">tstate</tt>:</p>
<pre class="literal-block">
_PyRuntimeState *runtime = tstate-&gt;interp-&gt;runtime;
</pre>
<p>This bug is a regression caused by my change:
<a class="reference external" href="https://github.com/python/cpython/commit/01b1cc12e7c6a3d6a3d27ba7c731687d57aae92a">Add PyInterpreterState.runtime field</a>
of <a class="reference external" href="https://bugs.python.org/issue36710">bpo-36710</a>. I replaced:</p>
<pre class="literal-block">
void PyEval_RestoreThread(PyThreadState *tstate) {
    _PyRuntimeState *runtime = &amp;_PyRuntime;
    ...
}
</pre>
<p>with:</p>
<pre class="literal-block">
void PyEval_RestoreThread(PyThreadState *tstate) {
    _PyRuntimeState *runtime = tstate-&gt;interp-&gt;runtime;
    ...
}
</pre>
</div>
<div class="section" id="fix-pyeval-restorethread-for-daemon-threads">
<h3>Fix PyEval_RestoreThread() for daemon threads</h3>
<p>I created <a class="reference external" href="https://bugs.python.org/issue39877">bpo-39877</a> to investigate
this bug. I managed to reproduce the crash on Linux with a script spawning
daemon threads which sleep randomly between 0.0 and 1.0 second, and by adding
<tt class="docutils literal">sleep(1);</tt> call at <tt class="docutils literal">Py_RunMain()</tt> exit.</p>
<p>I wrote a <tt class="docutils literal">PyEval_RestoreThread()</tt> fix which access to
<tt class="docutils literal">_PyRuntimeState.finalizing</tt> without the GIL.</p>
<p><strong>Antoine Pitrou</strong> asked me to convert <tt class="docutils literal">_PyRuntimeState.finalizing</tt> to an
atomic variable to avoid inconsistencies in case of parallel accesses. At March
7, 2020, I pushed <a class="reference external" href="https://github.com/python/cpython/commit/7b3c252dc7f44d4bdc4c7c82d225ebd09c78f520">commit 7b3c252d</a>:</p>
<pre class="literal-block">
bpo-39877: _PyRuntimeState.finalizing becomes atomic (GH-18816)

Convert _PyRuntimeState.finalizing field to an atomic variable:

* Rename it to _finalizing
* Change its type to _Py_atomic_address
* Add _PyRuntimeState_GetFinalizing() and _PyRuntimeState_SetFinalizing()
  functions
* Remove _Py_CURRENTLY_FINALIZING() function: replace it with testing
  directly _PyRuntimeState_GetFinalizing() value

Convert _PyRuntimeState_GetThreadState() to static inline function.
</pre>
<p>The day after, I pushed my fix, <a class="reference external" href="https://github.com/python/cpython/commit/eb4e2ae2b8486e8ee4249218b95d94a9f0cc513e">commit eb4e2ae2</a>:</p>
<pre class="literal-block">
bpo-39877: Fix PyEval_RestoreThread() for daemon threads (GH-18811)

* exit_thread_if_finalizing() does now access directly _PyRuntime
  variable, rather than using tstate-&gt;interp-&gt;runtime since tstate
  can be a dangling pointer after Py_Finalize() has been called.
* exit_thread_if_finalizing() is now called *before* calling
  take_gil(). _PyRuntime.finalizing is an atomic variable,
  we don't need to hold the GIL to access it.
</pre>
<p><tt class="docutils literal">exit_thread_if_finalizing()</tt> is now called <strong>before</strong> <tt class="docutils literal">take_gil()</tt> to
ensure that <tt class="docutils literal">take_gil()</tt> cannot be called with an invalid Python thread state
(<tt class="docutils literal">tstate</tt>).</p>
<p>I commented <em>naively</em>:</p>
<blockquote>
Ok, it should now be fixed.</blockquote>
</div>
</div>
<div class="section" id="clear-python-thread-states-earlier-my-first-failed-attempt-in-2013">
<h2>Clear Python thread states earlier: my first failed attempt in 2013</h2>
<p>In 2013, I opened <a class="reference external" href="https://bugs.python.org/issue19466">bpo-19466</a> to clear
earlier the Python thread state of threads during Python finalization. My
intent was to display <tt class="docutils literal">ResourceWarning</tt> warnings of daemon threads as well.
In November 2013, I pushed <a class="reference external" href="https://github.com/python/cpython/commit/45956b9a33af634a2919ade64c1dd223ab2d5235">commit 45956b9a</a>:</p>
<pre class="literal-block">
Close #19466: Clear the frames of daemon threads earlier during the Python
shutdown to call objects destructors. So &quot;unclosed file&quot; resource warnings
are now corretly emitted for daemon threads.
</pre>
<p>Later, I discovered a crash in the the garbage collector while trying to
reproduce a race condition in asyncio: I created <a class="reference external" href="https://bugs.python.org/issue20526">bpo-20526</a>. Sadly, this bug was trigger by my
previous change. I decided that it's safer to revert my change.</p>
<p>By the way, when I looked again at <a class="reference external" href="https://bugs.python.org/issue20526">bpo-20526</a>, I was able to reproduce again the
garbage collector bug, likely because of recent changes. With the help of
<strong>Pablo Galindo Salgado</strong>, Pablo and me <a class="reference external" href="https://bugs.python.org/issue20526#msg364851">understood the root issue</a>.  At March 24, 2020, I pushed
a fix (<a class="reference external" href="https://github.com/python/cpython/commit/5804f878e779712e803be927ca8a6df389d82cdf">commit</a>)
to finally fix this 6 years old bug! The fix removes the following line from
<tt class="docutils literal">PyThreadState_Clear()</tt>:</p>
<pre class="literal-block">
Py_CLEAR(tstate-&gt;frame);
</pre>
</div>
<div class="section" id="fix-3-exit-also-take-gil-at-exit-point-if-finalizing">
<h2>Fix 3: Exit also take_gil() at exit point if finalizing</h2>
<p>After fixing <tt class="docutils literal">PyEval_RestoreThread()</tt>, I decided to attempt again to fix
<a class="reference external" href="https://bugs.python.org/issue19466">bpo-19466</a> (clear earlier Python thread
states). Sadly, I discovered that my <tt class="docutils literal">PyEval_RestoreThread()</tt> fix
<strong>introduced a race condition</strong>!</p>
<p>While the main thread finalizes Python, daemon threads can be waiting for the
GIL: they block in <tt class="docutils literal">take_gil()</tt>. When the main thread releases the GIL during
finalization, a daemon thread take the GIL instead of exiting. Daemon threads
only check if they must exit <strong>before</strong> trying to take the GIL.</p>
<p>The solution is to call <tt class="docutils literal">exit_thread_if_finalizing()</tt> twice in
<tt class="docutils literal">take_gil()</tt>: before <strong>and</strong> after taking the GIL.</p>
<p>In March 2020, I pushed <a class="reference external" href="https://github.com/python/cpython/commit/9229eeee105f19705f72e553cf066751ac47c7b7">commit 9229eeee</a>:</p>
<pre class="literal-block">
bpo-39877: take_gil() checks tstate_must_exit() twice (GH-18890)

take_gil() now also checks tstate_must_exit() after acquiring
the GIL: exit the thread if Py_Finalize() has been called.
</pre>
<p>I commented:</p>
<blockquote>
<p>I ran multiple times <tt class="docutils literal">daemon_threads_exit.py</tt> with <tt class="docutils literal">slow_exit.patch</tt>:
no crash.</p>
<p>I also ran multiple times <tt class="docutils literal">stress.py</tt> + <tt class="docutils literal">sleep_at_exit.patch</tt> of
bpo-37135: no crash.</p>
<p>And I tested <tt class="docutils literal">asyncio_gc.py</tt> of bpo-19466: no crash neither.</p>
<p><strong>Python finalization now looks reliable.</strong> I'm not sure if it's &quot;more&quot;
reliable than previously, but at least, I cannot get a crash anymore, even
after bpo-19466 has been fixed (clear Python thread states of daemon
threads earlier).</p>
</blockquote>
<p>Funny fact, in June 2019, <strong>Eric Snow</strong> added a very similar bug in <a class="reference external" href="https://bugs.python.org/issue36818">bpo-36818</a> with <a class="reference external" href="https://github.com/python/cpython/commit/396e0a8d9dc65453cb9d53500d0a620602656cfe">commit 396e0a8d</a>:
test_multiprocessing_spawn segfault on FreeBSD (<a class="reference external" href="https://bugs.python.org/issue37135">bpo-37135</a>). I reverted his change to fix the
issue. At this time, I didn't have the bandwidth to investigate the root cause.
I just reverted Eric's change.</p>
</div>
<div class="section" id="fix-4-exit-take-gil-while-waiting-for-the-gil-if-finalizing">
<h2>Fix 4: Exit take_gil() while waiting for the GIL if finalizing</h2>
<p>While I was working on moving pending calls from <tt class="docutils literal">_PyRuntime</tt> to
<tt class="docutils literal">PyInterpreterState</tt>, <a class="reference external" href="https://bugs.python.org/issue39984">bpo-3998</a>, I had
another bug.</p>
<p>At March 18, 2020, I pushed a <tt class="docutils literal">take_gil()</tt> fix to avoid accessing <tt class="docutils literal">tstate</tt>
if Python is finalizing, <a class="reference external" href="https://github.com/python/cpython/commit/29356e03d4f8800b04f799efe7a10e3ce8b16f61">commit 29356e03</a>:</p>
<pre class="literal-block">
bpo-39877: Fix take_gil() for daemon threads (GH-19054)

bpo-39877, bpo-39984: If the thread must exit, don't access tstate to
prevent a potential crash: tstate memory has been freed.
</pre>
<p>And while working on the inefficient signal handling in multithreaded
applications (<a class="reference external" href="https://bugs.python.org/issue40010">bpo-40010</a>), I discovered
that the previous fix was not enough!</p>
<p>At March 19, 2020, I pushed a <tt class="docutils literal">take_gil()</tt> fix to exit while <tt class="docutils literal">take_gil()</tt>
is waiting for the GIL if Python is finalizing, <a class="reference external" href="https://github.com/python/cpython/commit/a36adfa6bbf5e612a4d4639124502135690899b8">commit a36adfa6</a>:</p>
<pre class="literal-block">
bpo-39877: 4th take_gil() fix for daemon threads (GH-19080)

bpo-39877, bpo-40010: Add a third tstate_must_exit() check in
take_gil() to prevent using tstate which has been freed.
</pre>
<p>I can only hope that this fix is the last one to fix all corner cases with
daemon threads in <tt class="docutils literal">take_gil()</tt> (<a class="reference external" href="https://bugs.python.org/issue39877">bpo-39877</a>)!</p>
</div>
<div class="section" id="summy-of-gil-bugfixes">
<h2>Summy of GIL bugfixes</h2>
<p>The GIL got 5 main bugfixes for daemon threads and Python finalization:</p>
<ul class="simple">
<li>May 2011, <strong>Antoine Pitrou</strong>,
<a class="reference external" href="https://github.com/python/cpython/commit/0d5e52d3469a310001afe50689f77ddba6d554d1">commit 0d5e52d3</a>:
<tt class="docutils literal">take_gil()</tt> exits if finalizing <strong>after</strong> taking the GIL (1 check)</li>
<li>April 2019, <strong>Joannah Nanjekye</strong>,
<a class="reference external" href="https://github.com/python/cpython/commit/f781d202a2382731b43bade845a58d28a02e9ea1">commit f781d202</a>:
PyEval_AcquireLock() and PyEval_AcquireThread() also exit if Python is finalizing</li>
<li>March 8, 2020, <strong>Victor Stinner</strong>,
<a class="reference external" href="https://github.com/python/cpython/commit/eb4e2ae2b8486e8ee4249218b95d94a9f0cc513e">commit eb4e2ae2</a>:
<tt class="docutils literal">take_gil()</tt> exits if finalizing <strong>before</strong> taking the GIL (1 check)</li>
<li>March 9, 2020, <strong>Victor Stinner</strong>,
<a class="reference external" href="https://github.com/python/cpython/commit/9229eeee105f19705f72e553cf066751ac47c7b7">commit 9229eeee</a>:
<tt class="docutils literal">take_gil()</tt> exits if finalizing <strong>before and after</strong> taking the GIL (2 checks)</li>
<li>March 19, 2020, <strong>Victor Stinner</strong>,
<a class="reference external" href="https://github.com/python/cpython/commit/a36adfa6bbf5e612a4d4639124502135690899b8">commit a36adfa6</a>:
<tt class="docutils literal">take_gil()</tt> exits if finalizing <strong>before, while, and after</strong> taking the GIL (3 checks)</li>
</ul>
</div>
                </article>
            </aside><!-- /#featured -->
                <section id="content" class="body">
                    <h1>Other articles</h1>
                    <hr />
                    <ol id="posts-list" class="hfeed">

            <li><article class="hentry">
                <header>
                    <h1><a href="https://vstinner.github.io/threading-shutdown-race-condition.html" rel="bookmark"
                           title="Permalink to Threading shutdown race condition">Threading shutdown race condition</a></h1>
                </header>

                <div class="entry-content">
<footer class="post-info">
        <abbr class="published" title="2020-04-03T20:00:00+02:00">
                Published: ven. 03 avril 2020
        </abbr>

        <address class="vcard author">
                By                         <a class="url fn" href="https://vstinner.github.io/author/victor-stinner.html">Victor Stinner</a>
        </address>
<p>In <a href="https://vstinner.github.io/category/cpython.html">cpython</a>.</p>
<p>tags: <a href="https://vstinner.github.io/tag/cpython.html">cpython</a> </p>
</footer><!-- /.post-info -->                <p>This article is about a race condition in threading shutdown that I fixed in
Python 3.9 in March 2019. I also forbid spawning daemon threads in
subinterpreters to fix another related bug.</p>
<a class="reference external image-reference" href="https://twitter.com/neeljulien/status/1240292383369150464"><img alt="#CoronaMaison by Julien Neel" src="https://vstinner.github.io/images/coronamaison_jneel.jpg" /></a>
<p>Drawing: <a class="reference external" href="https://twitter.com/neeljulien/status/1240292383369150464">#CoronaMaison by Julien Neel</a>.</p>
<div class="section" id="race-condition-in-threading-shutdown">
<h2>Race condition in threading shutdown</h2>
<div class="section" id="random-test-failure-noticed-on-freebsd-buildbot">
<h3>Random test failure noticed on FreeBSD buildbot …</h3></div></div>
                <a class="readmore" href="https://vstinner.github.io/threading-shutdown-race-condition.html">read more</a>
                </div><!-- /.entry-content -->
            </article></li>

            <li><article class="hentry">
                <header>
                    <h1><a href="https://vstinner.github.io/daemon-threads-python-finalization-python32.html" rel="bookmark"
                           title="Permalink to Daemon threads and the Python finalization in Python 3.2 and 3.3">Daemon threads and the Python finalization in Python 3.2 and 3.3</a></h1>
                </header>

                <div class="entry-content">
<footer class="post-info">
        <abbr class="published" title="2020-03-26T22:00:00+01:00">
                Published: jeu. 26 mars 2020
        </abbr>

        <address class="vcard author">
                By                         <a class="url fn" href="https://vstinner.github.io/author/victor-stinner.html">Victor Stinner</a>
        </address>
<p>In <a href="https://vstinner.github.io/category/cpython.html">cpython</a>.</p>
<p>tags: <a href="https://vstinner.github.io/tag/cpython.html">cpython</a> </p>
</footer><!-- /.post-info -->                <p>At exit, the Python finalization calls Python objects finalizers (the
<tt class="docutils literal">__del__()</tt> method) and deallocates memory.  The daemon threads are a special
kind of threads which continue to run during and after the Python finalization.
They are causing race conditions and tricky bugs in the Python finalization.</p>
<p>This article covers bugs …</p>
                <a class="readmore" href="https://vstinner.github.io/daemon-threads-python-finalization-python32.html">read more</a>
                </div><!-- /.entry-content -->
            </article></li>

            <li><article class="hentry">
                <header>
                    <h1><a href="https://vstinner.github.io/asyncio-proactor-wsasend-memory-leak.html" rel="bookmark"
                           title="Permalink to asyncio WSASend() memory leak">asyncio WSASend() memory leak</a></h1>
                </header>

                <div class="entry-content">
<footer class="post-info">
        <abbr class="published" title="2019-03-06T20:00:00+01:00">
                Published: mer. 06 mars 2019
        </abbr>

        <address class="vcard author">
                By                         <a class="url fn" href="https://vstinner.github.io/author/victor-stinner.html">Victor Stinner</a>
        </address>
<p>In <a href="https://vstinner.github.io/category/cpython.html">cpython</a>.</p>
<p>tags: <a href="https://vstinner.github.io/tag/asyncio.html">asyncio</a> </p>
</footer><!-- /.post-info -->                <p>I fixed multiple bugs in asyncio <tt class="docutils literal">ProactorEventLoop</tt> previously. But test_asyncio
still failed sometimes. I noticed a memory leak in <tt class="docutils literal">test_asyncio</tt> which will
haunt me for 1 year in 2018...</p>
<p><strong>Yet another example of a test failure which looks harmless but hides a
critical bug.</strong> The bug is that sending a …</p>
                <a class="readmore" href="https://vstinner.github.io/asyncio-proactor-wsasend-memory-leak.html">read more</a>
                </div><!-- /.entry-content -->
            </article></li>

            <li><article class="hentry">
                <header>
                    <h1><a href="https://vstinner.github.io/asyncio-proactor-wsarecv-cancellation-data-loss.html" rel="bookmark"
                           title="Permalink to asyncio: WSARecv() cancellation causing data loss">asyncio: WSARecv() cancellation causing data loss</a></h1>
                </header>

                <div class="entry-content">
<footer class="post-info">
        <abbr class="published" title="2019-01-31T15:20:00+01:00">
                Published: jeu. 31 janvier 2019
        </abbr>

        <address class="vcard author">
                By                         <a class="url fn" href="https://vstinner.github.io/author/victor-stinner.html">Victor Stinner</a>
        </address>
<p>In <a href="https://vstinner.github.io/category/cpython.html">cpython</a>.</p>
<p>tags: <a href="https://vstinner.github.io/tag/asyncio.html">asyncio</a> </p>
</footer><!-- /.post-info -->                <p>In December 2017, <strong>Yury Selivanov</strong> pushed the long awaited <tt class="docutils literal">start_tls()</tt>
function.</p>
<p>A newly added test failed on Windows. Later, the test started to fail
randomly on Linux as well. In fact, it was a well hidden race condition in the
asynchronous handshake of <tt class="docutils literal">SSLProtocol</tt> which will take 5 months of …</p>
                <a class="readmore" href="https://vstinner.github.io/asyncio-proactor-wsarecv-cancellation-data-loss.html">read more</a>
                </div><!-- /.entry-content -->
            </article></li>

            <li><article class="hentry">
                <header>
                    <h1><a href="https://vstinner.github.io/asyncio-proactor-connect-pipe-race-condition.html" rel="bookmark"
                           title="Permalink to Asyncio: Proactor ConnectPipe() Race Condition">Asyncio: Proactor ConnectPipe() Race Condition</a></h1>
                </header>

                <div class="entry-content">
<footer class="post-info">
        <abbr class="published" title="2019-01-30T18:00:00+01:00">
                Published: mer. 30 janvier 2019
        </abbr>

        <address class="vcard author">
                By                         <a class="url fn" href="https://vstinner.github.io/author/victor-stinner.html">Victor Stinner</a>
        </address>
<p>In <a href="https://vstinner.github.io/category/cpython.html">cpython</a>.</p>
<p>tags: <a href="https://vstinner.github.io/tag/asyncio.html">asyncio</a> </p>
</footer><!-- /.post-info -->                <p>Between December 2014 and January 2015, once I succeeded to fix the root issue
of the random asyncio crashes on Windows (<a class="reference external" href="https://vstinner.github.io/asyncio-proactor-cancellation-from-hell.html">Proactor Cancellation From Hell</a>), I fixed more race conditions
and bugs in <tt class="docutils literal">ProactorEventLoop</tt>:</p>
<ul class="simple">
<li><tt class="docutils literal">ConnectPipe()</tt> Race Condition</li>
<li>Race Condition in <tt class="docutils literal">BaseSubprocessTransport._try_finish()</tt></li>
<li>Close the transport on failure: ResourceWarning</li>
<li>Cleanup code …</li></ul>
                <a class="readmore" href="https://vstinner.github.io/asyncio-proactor-connect-pipe-race-condition.html">read more</a>
                </div><!-- /.entry-content -->
            </article></li>

            <li><article class="hentry">
                <header>
                    <h1><a href="https://vstinner.github.io/asyncio-proactor-cancellation-from-hell.html" rel="bookmark"
                           title="Permalink to Asyncio: Proactor Cancellation From Hell">Asyncio: Proactor Cancellation From Hell</a></h1>
                </header>

                <div class="entry-content">
<footer class="post-info">
        <abbr class="published" title="2019-01-28T20:20:00+01:00">
                Published: lun. 28 janvier 2019
        </abbr>

        <address class="vcard author">
                By                         <a class="url fn" href="https://vstinner.github.io/author/victor-stinner.html">Victor Stinner</a>
        </address>
<p>In <a href="https://vstinner.github.io/category/cpython.html">cpython</a>.</p>
<p>tags: <a href="https://vstinner.github.io/tag/asyncio.html">asyncio</a> </p>
</footer><!-- /.post-info -->                <p>Between 2014 and 2015, I was working on the new shiny <tt class="docutils literal">asyncio</tt> module
(module added to Python 3.4 released in March 2014). I helped to stabilize the
Windows implementation because... well, nobody else was paying attention to it,
and I was worried that test_asyncio <strong>randomly crashed</strong> on Windows.</p>
<p>One …</p>
                <a class="readmore" href="https://vstinner.github.io/asyncio-proactor-cancellation-from-hell.html">read more</a>
                </div><!-- /.entry-content -->
            </article></li>

            <li><article class="hentry">
                <header>
                    <h1><a href="https://vstinner.github.io/locale-bugfixes-python3.html" rel="bookmark"
                           title="Permalink to Locale Bugfixes in Python 3">Locale Bugfixes in Python 3</a></h1>
                </header>

                <div class="entry-content">
<footer class="post-info">
        <abbr class="published" title="2019-01-09T00:30:00+01:00">
                Published: mer. 09 janvier 2019
        </abbr>

        <address class="vcard author">
                By                         <a class="url fn" href="https://vstinner.github.io/author/victor-stinner.html">Victor Stinner</a>
        </address>
<p>In <a href="https://vstinner.github.io/category/cpython.html">cpython</a>.</p>
<p>tags: <a href="https://vstinner.github.io/tag/unicode.html">unicode</a> <a href="https://vstinner.github.io/tag/locales.html">locales</a> </p>
</footer><!-- /.post-info -->                <p>This article describes a few locales bugs that I fixed in Python 3 between 2012
(Python 3.3) and 2018 (Python 3.7):</p>
<ul class="simple">
<li>Support non-ASCII decimal point and thousands separator</li>
<li>Crash with non-ASCII decimal point</li>
<li>LC_NUMERIC encoding different than LC_CTYPE encoding</li>
<li>LC_MONETARY encoding different than LC_CTYPE encoding</li>
<li>Tests non-ASCII locales …</li></ul>
                <a class="readmore" href="https://vstinner.github.io/locale-bugfixes-python3.html">read more</a>
                </div><!-- /.entry-content -->
            </article></li>

            <li><article class="hentry">
                <header>
                    <h1><a href="https://vstinner.github.io/python3-locales-encodings.html" rel="bookmark"
                           title="Permalink to Python 3, locales and encodings">Python 3, locales and encodings</a></h1>
                </header>

                <div class="entry-content">
<footer class="post-info">
        <abbr class="published" title="2018-09-06T16:00:00+02:00">
                Published: jeu. 06 septembre 2018
        </abbr>

        <address class="vcard author">
                By                         <a class="url fn" href="https://vstinner.github.io/author/victor-stinner.html">Victor Stinner</a>
        </address>
<p>In <a href="https://vstinner.github.io/category/cpython.html">cpython</a>.</p>
<p>tags: <a href="https://vstinner.github.io/tag/unicode.html">unicode</a> <a href="https://vstinner.github.io/tag/locales.html">locales</a> </p>
</footer><!-- /.post-info -->                <p>Recently, I worked on a change which looked simple: move the code to initialize
the <tt class="docutils literal">sys.stdout</tt> encoding before <tt class="docutils literal">Py_Initialize()</tt>. While I was on it,
I also decided to move the code which selects the Python &quot;filesystem encoding&quot;.
I didn't expect that I would spend 2 weeks on these issues …</p>
                <a class="readmore" href="https://vstinner.github.io/python3-locales-encodings.html">read more</a>
                </div><!-- /.entry-content -->
            </article></li>
                </ol><!-- /#posts-list -->
                </section><!-- /#content -->
        <section id="extras" class="body">
                <div class="blogroll">
                        <h2>links</h2>
                        <ul>
                            <li><a href="http://vstinner.readthedocs.org/">Victor Stinner's Notes</a></li>
                        </ul>
                </div><!-- /.blogroll -->
                <div class="social">
                        <h2>social</h2>
                        <ul>
                            <li><a href="https://vstinner.github.io/feeds/all.atom.xml" type="application/atom+xml" rel="alternate">atom feed</a></li>

                            <li><a href="https://twitter.com/VictorStinner">Follow @VictorStinner on Twitter</a></li>
                        </ul>
                </div><!-- /.social -->
        </section><!-- /#extras -->

        <footer id="contentinfo" class="body">
                <address id="about" class="vcard body">
                Proudly powered by <a href="http://getpelican.com/">Pelican</a>, which takes great advantage of <a href="http://python.org">Python</a>.
                </address><!-- /#about -->

                <p>The theme is by <a href="http://coding.smashingmagazine.com/2009/08/04/designing-a-html-5-layout-from-scratch/">Smashing Magazine</a>, thanks!</p>
        </footer><!-- /#contentinfo -->

</body>
</html>